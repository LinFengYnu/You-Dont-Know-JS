## 语法
语言规则的定义。语法和词法有细微的差别。JavaScript语法定义了词法规则。

### 语句和表达式
语句相当于句子，表达式相当于短语，运算符则相当于标点符号和连接词。

* 可以返回一个结果值的都是表达式。
* 有几种包含表达式的语句：声明语句/赋值语句/表达式语句

#### 语句的结果值
语句都有一个结果值,很多情况是undefined

* 代码块{ .. }的结果值是其最后一个语句/表达式的结果。
* 语句的结果值不允许赋值给别的变量。除非使用eval(不推荐！)，还有个ES7的do方案可以解决
* delete运算符也会返回结果


#### 表达式的副作用
最常见的有副作用（也可能没有）的表达式是函数调用。

* 递增(减)运算符也会造成副作用，可以使用,语句系列逗号运算符b = ( a++, a ); 达到作者的目的
* =赋值运算符也有副作用,但在链式赋值的时候非常有用

#### 上下文规则
同样的语法在不同的情况下会有不同的解释。

##### 大括号
* 声明对象和标签语句。带标签的break和continue可以执行一些特殊需求的任务
```
{ 
    foo: bar() 
}
```
* JSON是JavaScript语法的一个子集，但是JSON本身并不是合法的JavaScript语法。JSON-P能将JSON转换为合法的
JavaScript语法。
* {}可能会当做空对象也有可能被当作空代码块

```
[] + {}; // "[object Object]" 
{} + []; // 0
```
* { .. }也可用于“解构赋值”
```
var { a, b } = { 
        a: 42, 
        b: "foo"  
}; 
```
* { .. }还可以用作函数命名参数（named function argument）的对象解构
```
function foo({ a, b, c }) { 
    console.log( a, b, c ); 
} 
 
foo( { 
    c: [1,2,3], 
    a: 42, 
    b: "foo" 
} );    // 42 "foo" [1, 2, 3]
```
* JS的else if是假的
### 运算符优先级
超过一个运算符时表达式的执行顺序是很重要的。

* ,的优先级最低,()最高
* &&运算符先于||执行,不一定是从左到右
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence有列表

#### 短路
即执行最短路径。

* 如同一道安全保护。避免执行不必要的代码。

#### 更强的绑定
多个相同优先级的运算符同时出现看运算符的关联。

#### 关联
从左到右结合还是反过来结合

* 比如&&是左结合,?:和=是右结合
* 举个例子var d = a && b || c ? c || b ? a : c && b : a;
```
( 
  (a && b) 
    ||  
  c 
) 
  ? 
( 
  (c || b) 
    ?  
  a 
    : 
  (c && b) 
)  
  : 
a
```

#### 释疑
根据情况依赖规则编码或者使用显式和自行控制的方式。我选择用()显式控制。( )有助于提高代码可读性。依赖规则只是简洁了。

### 自动分号
自动分号插入（Automatic Semicolon Insertion，ASI）

* ASI在某些情况下很有用，特别是开发人员记不得语法的时候。
* ASI之争我选择加分号，这是个良好的习惯。毕竟它的设计之初就是为了纠错。

### 错误
分为运行时错误和编译时(早期)错误。

* 语法错误是早期错误的一种。
* 早期错误无法捕获，比如非法的正则表达式、赋值对象不是标识符、严格模式中，函数的参数重名等等。它们是词法错误不是语法错误，但是一些浏览器选择用SyntaxError来代替。

#### 提前使用变量
TDZ（Temporal Dead Zone，暂时性死区），指的是由于代码中的变量还没有初始化而不能被引用的情况。

### 函数参数
ES6中的参数默认值违反了TDZ，没有let也可以访问。

* 神奇的arguments,在开发中不要依赖这种关联机制。
* 实在要访问arguments,就不要同时访问命名参数和其对应的arguments数组单元。

### try...finally
try中有return语句还是会执行finally语句，finally中的return会覆盖try和catch中return的返回值。

* ES6的yield是return的中间版本,finally不会在yield之后立即执行。

### switch
它的匹配基于===

* case中可以出现各种表达式,switch设为true就行了。但要小心&&和||
* 小心使用break
