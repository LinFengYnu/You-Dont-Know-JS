## 强制类型转换
优缺点辩证地看。
### 值类型转换
有显式和隐式。

* 强制类型转换总是返回标量基本类型值。
* 类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）。
* 用“隐式强制类型转换”（implicit coercion）和“显式强制类型转换”（explicitcoercion）来区分强制类型转换。

```
var a = 42; 
var b = a + "";         // 隐式强制类型转换 
var c = String( a );    // 显式强制类型转换
```
### 抽象值操作
着重介绍ToString、ToNumber和ToBoolean，附带讲一讲ToPrimitive。
#### ToString
非字符串到字符串的强制类型转换。

* null转换为"null"，undefined转换为"undefined"，true转换为"true"。
极小和极大的数字使用指数形式。
* 对象返回内部属性[[Class]]的值
* 数组的默认toString()方法经过了重新定义
```
var a = [1,2,3]; 
a.toString(); // "1,2,3"
```
* JSON.stringify(..)也用到了ToString。必须是符合安全标准的JSON。但它不是强制类型转换。
* 如果要对含有非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义toJSON()方法来返回一个安全的JSON值。
* 可以向JSON.stringify(..)传递一个可选参数replacer，它可以是数组或者函数。还有一个可选参数space，用来指定输出的缩进格式。

#### ToNumber
将非数字值当作数字来使用时会触发。

* 布尔值->0或1
* 字符串的处理基本遵循数字常量的相关规则/语法，失败返回NaN。0x不按十六进制处理。
* 对象先转成基本类型值（ToPrimitive）,再调用valueOf和toString,再按上面规则转。（使用Object.create(null)创建的对象无法进行强制类型转换，因为它关联的是null）

#### ToBoolean
JS中布尔值和数字是不一样的。

##### 假值
ES5规范9.2节中定义了抽象操作ToBoolean

*  undefined、null、false、+0、-0和NaN、""
* 非假值都是真值

##### 假值对象
假值并非被封装成了对象，而是强制转换后为false的对象。

* 外来对象比如DOM的document.all，曾经用来判断是否是IE，它被强制转换成false

##### 真值
不在假值列表的就是真值。

* 背下假值表
* []有例外

### 显式强制类型转换
没什么坑。

#### 字符串和数字之间的显式转换
通过String(..)和Number(..)实现。

* 调用toString()（这里显式转换中含有隐式转换）和+操作符可以达到一样的效果。
* 不要和++ +=等弄混。

##### 日期显式转换为数字
+可以将日期（Date）对象强制类型转换为数字。

* 最好还是使用ES5的Date.now()或者new Date(..).getTime()来获得指定时间的时间戳。

##### 奇特的~运算符
这种字位运算符会强制操作数使用32位格式。

* 0 | ___是显式还是隐式仍存在争议。
* ~	其实是返回补码。~和indexOf()一起可以将结果强制类型转换。
```
if (~a.indexOf( "lo" )) {   // true 
    // 找到匹配！ 
} 
```

##### 字位截除
~~用来取整，原理是它只适用于32位数字，在负数上和Math.floor不一样，其实x | 0也可以也可以。

#### 显式解析数字字符串
解析(parseInt)和转换(Number)有明显的差别。

* 解析允许字符串中含有非数字字符，而转换不允许出现非数字字符。
* 避免向parseInt(..)传递非字符串参数。小心它的第二个参数。
* parseInt(1/0, 19)实际上是parseInt("Infinity", 19)。I在19进制里代表18
* 不要甩锅给parseInt
```
parseInt( 0.000008 );       // 0   ("0" 来自于 "0.000008") 
parseInt( 0.0000008 );      // 8   ("8" 来自于 "8e-7") 
parseInt( false, 16 );      // 250 ("fa" 来自于 "false") 
parseInt( parseInt, 16 );   // 15  ("f" 来自于 "function..") 
 
parseInt( "0x10" );         // 16 
parseInt( "103", 2 );       // 2
```

#### 显式转换为布尔值
!!比Boolean( .. )用的多。

* 在if(..)..这样的布尔值上下文中会隐式转换成布尔值。
* 三元运算符涉及到了隐式类型转换。

### 隐式强制类型转换
隐蔽的强制类型转换。比较难读懂。好处是是减少冗余，让代码更简洁。

#### 隐式地简化
不要因噎废食。实际上隐式转换过程是简化了底层实现细节。
```
SomeType x = SomeType( AnotherType( y ) )
SomeType x = SomeType( y )
```

#### 字符串和数字之间的隐式强制类型转换
先来看一些会产生隐式强制类型转换的操作。

* +先对能转成字符串的部分进行操作，对象处理要复杂些。不能转字符串就执行加法
* 可以将数字和空字符串 ""相+来将其转换为字符串，这和String()显式转换不一样，一个是使用valueOf一个是使用toString
* a - 0会将a强制类型转换为数字，乘1和除1也是可以的

#### 布尔值到数字的隐式强制类型转换
使用onlyOne函数作为例子讲解。
```
function onlyOne() { 
    var sum = 0; 
    for (var i=0; i < arguments.length; i++) { 
        // 跳过假值，和处理0一样，但是避免了NaN 
        if (arguments[i]) { 
            sum += arguments[i]; 
        } 
    } 
    //这里换成x就代表可以接收几个真值。
    return sum == 1; 
}
```
* 将真值（true/truthy）转换为1
* 显式转换可以避免NaN带来的问题


#### 隐式强制类型转换为布尔值
最为常见也最容易搞错。

* if (..)语句中的条件判断表达式。
* for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）。
* while (..)和do..while(..)循环中的条件判断表达式。
*  ? :中的条件判断表达式。
* 逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。

#### ||和&&
称它们为“选择器运算符”（selector operators）更恰当些。

* &&和||运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。
* a || b大致相当于a ? a : b， a && b大致相当于a ? b : a
* ||常用来当空值合并运算符,&&常用来当守护运算符(压缩工具常用)

#### 符号的强制类型转换
Symbol的强制类型转换有一个坑，允许显式转字符串却不允许隐式。

* 符号不能够被强制类型转换为数字,可以被强制类型转换为布尔值（显式和隐式结果都是true）

### 宽松相等和严格相等
==允许在相等比较中进行强制类型转换，而===不允许。

#### 相等比较操作的性能
如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用==，没有就用===，不用在乎性能。

#### 抽象相等
ES5规范11.9.3节的“抽象相等比较算法”定义了==运算符的行为。简称宽松相等。

* ==在比较两个不同类型的值时会发生隐式强制类型转换。
* 转换规则在ES5规范11.9.3.4-5里。
* 布尔值和其他类型比较容易出错。原因是布尔值会先转成数字。什么情况下都不要使用== true和== false。
* 在==中null和undefined是一回事，其他的假值不等于它们
* 对象和标量值比较的时候,对对象进行ToPromitive操作，null/undefined/NaN是例外因为不能封装和本身不等。

#### 比较少见的情况
避免他们。

* 更改内置对象的方法造成bug。
* ==的非常规情况,小心大家都被转成0
```
"0" == false;          // true -- 晕！ 
false == 0;            // true -- 晕！ 
false == "";           // true -- 晕！ 
false == [];           // true -- 晕！ 
"" == 0;               // true -- 晕！ 
"" == [];              // true -- 晕！ 
0 == [];               // true -- 晕！
```
* [] == ![]   // true因为![]被转成了fasle。[null]会直接转换为""。
* 如果两边的值中有true或者false，千万不要使用==。
* 如果两边的值中有[]、""或者0，尽量不要使用==。
* 为了安全起见还是用===吧。typeof也是可以的。


### 抽象关系比较
a < b中涉及的隐式强制类型转换

* 比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。
* 奇怪的例子,<=和>=是将>和<的结果反转
```
var a = { b: 42 }; 
var b = { b: 43 }; 
 
a < b;  // false 
a == b; // false 
a > b;  // false 
 
a <= b; // true 
a >= b; // true
```
* 关系比较没有“严格关系比较”,所以要谨慎使用