## 作用域是什么
1. 变量是有状态的。
2. 作用域是存储、查找变量的一套规则。

### 编译原理
1. 其实JS是一门编译语言。只不过它不是提前编译的，也不能在分布式系统中移植。
2. 传统编译流程有三个阶段
	2.1 分词/词法分析,把字符串分成token。 
	2.2 解析/语法分析,把词法单元流转换成抽象语法树。（AST）
	2.3 代码生成。把抽象语法树转换成代码。
3. JS的编译过程非常复杂。会在语法分析和代码生成阶段优化。
4. JS编译发生在执行前的瞬间。（JIT可优化）

### 理解作用域
以 var a = 2; 为例
#### 演员表
1. 引擎	`项目经理`
2. 编译器 `码农`
3. 作用域 `财务`

#### 对话
编译器会这样处理：
1. 遇到var a，判断同一个作用域里有没有a，有就忽略，没有就要求作用域创建一个新的变量a。
2. 编译器生成代码处理a = 2，引擎在作用域集合中查找该变量，如果能够找到就会对它赋值。如果找不到就抛出异常。

#### 编译器的术语
引擎会为变量a进行LHS查询。另外一个查找的类型叫作RHS。赋值操作的目标是谁（LHS），谁是赋值操作的源头
（RHS）。
编译器可以在代码生成的同时处理声明和值的定义。因此，将函数声明理解成前面讨论的LHS查询和赋值的形式并
不合适。


#### 引擎和作用域的对话
1.引擎需要RHS引用foo，询问作用域
2.作用域知道编译器声明了foo
3.引擎执行foo，发现需要对a进行LHS引用，询问作用域
4.作用域知道编译器把它声明为foo的形参了
5.引擎把2赋值给a
6.引擎要RHS引用console，询问作用域
7.作用域知道console是个内置对象
8.引擎找到console的log函数
9.引擎需要LHS引用a
10.作用域知道有个a
11.引擎把a传进log函数

#### 小测验
```
function foo(a) { 
    var b = a; 
    return a + b; 
} 
 
var c = foo( 2 );
```
我的答案：
LHS：
1.引擎执行foo，发现需要对a进行LHS引用
2.引擎需要LHS引用b
3.引擎需要LHS引用c
RHS：
1.引擎需要RHS引用foo
2.在赋值给b的时候，引擎需要RHS引用a
3.返回foo的值的时候需要RHS引用a
4.返回foo的值的时候需要RHS引用b

参考答案：
LHS：
c = ..;、a = 2（隐式变量分配）、b = ..
RHS：
foo(2..、= a;、a ..、.. b

### 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。词法作用域一直扩大。


### 异常
如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。如果找到了，但是进行了不合理的操作，引擎会抛出另外一种类型的异常，叫作TypeError。
当引擎执行LHS查询时，如果无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。（非严格模式）
