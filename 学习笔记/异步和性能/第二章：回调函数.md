## 回调函数
回调是这门语言中最基础的异步模式。它是事件循环“回头调用”到程序中的目标。
### continuation
回调函数封装了程序的延续(continuation)。

* 当回调函数变多时，代码就会变得难以维护

### 顺序的大脑
人其实也是单线程。并行执行任务的错觉是因为片段太微小了。

#### 执行与计划
计划是A->B->C,但是实际情况可能是B要等A,C要等B,就发生阻塞。

* 大脑工作方式和回调函数不一样。
* 不理解自己的代码才是地狱。

#### 嵌套回调与链式回调
回调地狱。

* 作者举了一个例子，首先难以判断出各个回调函数的执行顺序，然后万一有函数不是异步是同步就炸了。
* 如果不嵌套,而是链式回调,调试的时候代码会跳来跳去。
* 当回调面临的情况变复杂后,大脑会炸掉。

### 信任问题
小心控制反转，就是有一部分代码是第三方提供的，不在我们控制之下。

#### 五个回调的故事
考虑调用回调过早/过晚/调用回调的次数太少或太多/没有把所需的环境或参数成功传给你的回调函数/吞掉可能出现的错误或异常；

#### 不只是别人的代码
自己的代码也会有坑	

* 应该在内部函数中构建一些防御性的输入参数检查
* 比如类型检查
* 回调函数并没有检查机制

### 省点回调
为了更优雅地处理错误，有些API设计提供了分离回调。省略不会调用的回调。

* Promise的设计就是这样。
* 还有一种常见的回调模式叫作“error-first 风格”,Node风格
* 但实际上都是自己骗自己，实际上调用过迟就要加定时器，避免调用过早的话要永远异步调用回调
* 如果不确定关注的API会不会永远异步执行，可以创建一个asyncify(..)工具，让代码只能异步运行
* 还是换一种思路解决问题吧