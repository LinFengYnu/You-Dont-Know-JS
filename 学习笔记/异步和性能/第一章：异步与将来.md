## 异步
控制现在执行的和将来执行的程序。

* 等待用户输入
* 从数据库或文件系统中请求数据
* 通过网络发送数据并等待响应
* 以固定时间间隔执行重复任务

### 分块的程序
JS程序一定是由多个块构成的。现在无法完成的任务将会异步完成。

* 最简单的是使用回调函数
```
// ajax(..)是某个库中提供的某个Ajax函数 
ajax( "http://some.url.1", function myCallbackFunction(data){ 
 
    console.log( data ); // 耶！这里得到了一些数据！ 
 
} );
```
* ajax不建议用同步，因为那会阻塞所有的交互
* 任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。
#### 异步控制台
有时候控制台I/O会延迟

* 在JavaScript调试器中使用断点
* 把对象序列化到一个字符串中

### 事件循环
一种机制,处理程序中多个块的执行，且执行每块时调用JavaScript引擎。

* 用队列来存储事件,如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。
* 定时器在时间到后把函数放进队列。
* ES6对于件循环的工作细节有了精确的控制。

### 并行线程
异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。

* 并行计算最常见的工具就是进程和线程（它们可能同时运行）。多个线程能够共享单个进程的内存。
* 事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。
* 多线程编程是非常复杂的。因为语句的执行顺序是个大问题。

#### 完整运行
由于单线程特性，一旦一个函数开始运行，下一个函数必须等他运行完为止才能运行。

* 函数顺序的不确定性就是通常所说的竞态条件

### 并发
以一个下滑刷新为例子,宏观并行，微观串行。

* 单线程事件循环是并发的一种形式。

#### 非交互
如果进程间没有相互影响的话，不确定性是完全可以接受的。
#### 交互
如果出现交互，就需要对它们的交互进行协调以避免竞态的出现。

* 强行协调制造顺序。
```
function response(data) {  
    if (data.url == "http://some.url.1") {  
        res[0] = data;  
    }  
    else if (data.url == "http://some.url.2") {  
        res[1] = data;  
    }  
}
```
* 使用门来控制,大家都来了才开门
```
if (a && b) {  
    baz();  
}  
```
* 使用门栓来控制，只允许第一名通过
```
if (!a) {  
    a = x * 2;  
    baz();  
}  
```

#### 协作
创建一个协作性更强更友好且不会霸占事件循环队列的并发系统。

* 异步地批处理这些结果。每次处理之后返回事件循环。
```
var res = [];  
 
// response(..)从Ajax调用中取得结果数组 
function response(data) {  
    // 一次处理1000个 
    var chunk = data.splice( 0, 1000 );  
 
    // 添加到已有的res组 
    res = res.concat(  
        // 创建一个新的数组把chunk中所有值加倍 
        chunk.map( function(val){  
            return val * 2;  
        } )  
    );  
 
    // 还有剩下的需要处理吗？ 
    if (data.length > 0) {  
        // 异步调度下一次批处理 
        setTimeout( function(){  
            response( data );  
        }, 0 );  
    }  
}  
```
* 两个连续的setTimeout(..0)调用可能会出现定时器漂移。

### 任务
ES6新增了任务队列。它是挂在事件循环队列的每个tick之后的一个队列。相当于插队。

* 假如事件循环队列里有AB,任务队列里有CD,会打印ACDB
* Promise的异步特性是基于任务

### 语句顺序
代码中语句的顺序和JavaScript引擎执行语句的顺序并不一定要一致。

* JavaScript引擎在编译期间执行安全的优化会把代码变成我们意想不到的样子，但是可以执行。
* 但编译器重新排序会产生可见的副作用,比如会产生副作用的函数调用（特别是getter函数），或ES6代理对象
